y <- dum
dff <- data.frame(x,y)
apply(dff,2,splitc)
tt <- t.test(ctrlx1, expx1,
alternative = "two.sided", var.equal = FALSE)
# print(tt)
tstatssi[i] <- tt$statistic # where i is the column number (x) inputted
return(tstatssi)
}
}
ttesting(matr,dum)
dum <- rep(0:1, times = 52)
dum <- rep(0:1, times = 52)
y <- dum
dff <- data.frame(x,y)
dff
x
matr
ttesting <- function(matr,dum){
tstatssi <<- vector("double", length = ncol(mat))
for (i in 1:ncol(matr)) {
x <- vector('numeric', length = nrow(mat))
x <- i
y <- dum
dff <- data.frame(x,y)
print(dff)
apply(dff,2,splitc)
tt <- t.test(ctrlx1, expx1,
alternative = "two.sided", var.equal = FALSE)
# print(tt)
tstatssi[i] <- tt$statistic # where i is the column number (x) inputted
return(tstatssi)
}
}
ttesting(matr,dum)
c <- c(runif(104,1,104))
g <- rep(0:1, times = 52)
df <-data.frame(c,g)
matr <- matrix((runif(104,1,104)), nrow = 52)
dum <- rep(0:1, times = 52)
x <- vector("numeric")
x <- matr[1]
x <- matr[,1]
ttesting <- function(matr,dum){
tstatssi <<- vector("double", length = ncol(mat))
for (i in 1:ncol(matr)) {
x <- vector("numeric")
x <- matr[,i]
y <- dum
dff <- data.frame(x,y)
print(dff)
apply(dff,2,splitc)
tt <- t.test(ctrlx1, expx1,
alternative = "two.sided", var.equal = FALSE)
# print(tt)
tstatssi[i] <- tt$statistic # where i is the column number (x) inputted
return(tstatssi)
}
}
ttesting(matr,dum)
dum
y <- dum[1:length(dum)]
y
dff <- data.frame(x,y)
print(dff)
y <- dum[1:nrow(matr)]
dff <- data.frame(x,y)
print(dff)
ttesting <- function(matr,dum){
tstatssi <<- vector("double", length = ncol(mat))
for (i in 1:ncol(matr)) {
x <- vector("numeric")
x <- matr[,i]
y <- dum[1:nrow(matr)]
dff <- data.frame(x,y)
print(dff)
apply(dff,2,splitc)
tt <- t.test(ctrlx1, expx1,
alternative = "two.sided", var.equal = FALSE)
# print(tt)
tstatssi[i] <- tt$statistic # where i is the column number (x) inputted
return(tstatssi)
}
}
ttesting(matr,dum)
splitted <- apply(dff,2,splitc)
splitted <- apply(dff,2,splitc)
ttesting <- function(matr,dum){
tstatssi <<- vector("double", length = ncol(mat))
for (i in 1:ncol(matr)) {
x <- vector("numeric")
x <- matr[,i]
y <- dum[1:nrow(matr)]
dff <- data.frame(x,y)
print(dff)
splitted <- apply(dff,2,splitcc)
tt <- t.test(ctrlx1, expx1,
alternative = "two.sided", var.equal = FALSE)
# print(tt)
tstatssi[i] <- tt$statistic # where i is the column number (x) inputted
return(tstatssi)
}
}
ttesting(matr,dum)
nrow(dff)
dim(dff)
splitcc <-function(dff){ # where dff is a data frame of x and y,
#x is a column/list and y is a dummy variable 0/1
ctrlx1 <<- vector("numeric")
expx1 <<- vector("numeric")
# splitt <<- matrix(,nrow = 2,ncol=52)
for (i in 1:nrow(dff)) {
yn <- as.integer(dff[i,2])
if (yn==0){ # print("True")
ctrlx1[i]<-dff[i,1]
ctrlx1<-ctrlx1[!is.na(ctrlx1)] #ta global ass
ctrlx1 <<- ctrlx1
# print(ctrlx)
} else { # print("False")
expx1[i]<-dff[i,1]
expx1<-expx1[!is.na(expx1)]
expx1 <<- expx1 # ta global ass
# print(expx)
}
}
print(ctrlx1)
print(expx1)
}
ttesting <- function(matr,dum){
tstatssi <<- vector("double", length = ncol(mat))
for (i in 1:ncol(matr)) {
x <- vector("numeric")
x <- matr[,i]
y <- dum[1:nrow(matr)]
dff <- data.frame(x,y)
print(dff)
splitted <- apply(dff,2,splitcc)
tt <- t.test(ctrlx1, expx1,
alternative = "two.sided", var.equal = FALSE)
# print(tt)
tstatssi[i] <- tt$statistic # where i is the column number (x) inputted
return(tstatssi)
}
}
ttesting(matr,dum)
#
#
## testing tt
tt <- t.test(mat[,2],mat[,3],
alternative = "two.sided", var.equal = FALSE)
ttesting <- function(matr,dum){
tstatssi <<- vector("double", length = ncol(mat))
for (i in 1:ncol(matr)) {
x <- vector("numeric")
x <- matr[,i]
y <- dum[1:nrow(matr)]
dff <- data.frame(x,y)
print(dff)
splitted <- apply(dff,1,splitcc)
tt <- t.test(ctrlx1, expx1,
alternative = "two.sided", var.equal = FALSE)
# print(tt)
tstatssi[i] <- tt$statistic # where i is the column number (x) inputted
return(tstatssi)
}
}
ttesting(matr,dum)
dim(dff)
splitcc <-function(dff){ # where dff is a data frame of x and y,
#x is a column/list and y is a dummy variable 0/1
ctrlx1 <<- vector("numeric")
expx1 <<- vector("numeric")
# splitt <<- matrix(,nrow = 2,ncol=52)
for (i in 1:nrow(dff)) {
yn <- as.integer(dff[i,2, drop=FALSE])
if (yn==0){ # print("True")
ctrlx1[i]<-dff[i,1, drop=FALSE]
ctrlx1<-ctrlx1[!is.na(ctrlx1)] #ta global ass
ctrlx1 <<- ctrlx1
# print(ctrlx)
} else { # print("False")
expx1[i]<-dff[i,1, drop=FALSE]
expx1<-expx1[!is.na(expx1)]
expx1 <<- expx1 # ta global ass
# print(expx)
}
}
print(ctrlx1)
print(expx1)
}
ttesting(matr,dum)
splitcc <-function(dff){ # where dff is a data frame of x and y,
#x is a column/list and y is a dummy variable 0/1
ctrlx1 <<- vector("numeric")
expx1 <<- vector("numeric")
# splitt <<- matrix(,nrow = 2,ncol=52)
for (i in 1:nrow(dff[,1:2])) {
yn <- as.integer(dff[i,2, drop=FALSE])
if (yn==0){ # print("True")
ctrlx1[i]<-dff[i,1, drop=FALSE]
ctrlx1<-ctrlx1[!is.na(ctrlx1)] #ta global ass
ctrlx1 <<- ctrlx1
# print(ctrlx)
} else { # print("False")
expx1[i]<-dff[i,1, drop=FALSE]
expx1<-expx1[!is.na(expx1)]
expx1 <<- expx1 # ta global ass
# print(expx)
}
}
print(ctrlx1)
print(expx1)
}
ttesting <- function(matr,dum){
tstatssi <<- vector("double", length = ncol(mat))
for (i in 1:ncol(matr)) {
x <- vector("numeric")
x <- matr[,i]
y <- dum[1:nrow(matr)]
dff <- data.frame(x,y)
print(dff)
splitted <- apply(dff,2,splitcc)
tt <- t.test(ctrlx1, expx1,
alternative = "two.sided", var.equal = FALSE)
# print(tt)
tstatssi[i] <- tt$statistic # where i is the column number (x) inputted
return(tstatssi)
}
}
ttesting(matr,dum)
splitcc <-function(dff){ # where dff is a data frame of x and y,
#x is a column/list and y is a dummy variable 0/1
ctrlx1 <<- vector("numeric")
expx1 <<- vector("numeric")
# splitt <<- matrix(,nrow = 2,ncol=52)
for (i in 1:nrow(dff[,])) {
yn <- as.integer(dff[i,2, drop=FALSE])
if (yn==0){ # print("True")
ctrlx1[i]<-dff[i,1, drop=FALSE]
ctrlx1<-ctrlx1[!is.na(ctrlx1)] #ta global ass
ctrlx1 <<- ctrlx1
# print(ctrlx)
} else { # print("False")
expx1[i]<-dff[i,1, drop=FALSE]
expx1<-expx1[!is.na(expx1)]
expx1 <<- expx1 # ta global ass
# print(expx)
}
}
print(ctrlx1)
print(expx1)
}
ttesting(matr,dum)
# changed to 1:nrow(dff[,])
# yields Error in dff[, ] : incorrect number of dimensions
# browser: function: nrow
# function (x)
# dim(x)[1L]
# but dimensions of dff is 2
dim(dff)
# changed to 1:nrow(dff[,])
# yields Error in dff[, ] : incorrect number of dimensions
# browser: function: nrow
# function (x)
# dim(x)[1L]
# but dimensions of dff is 2
dim(dff)
splitcc <-function(dff){ # where dff is a data frame of x and y,
#x is a column/list and y is a dummy variable 0/1
ctrlx1 <<- vector("numeric")
expx1 <<- vector("numeric")
# splitt <<- matrix(,nrow = 2,ncol=52)
for (i in 1:nrow(matr)) {
yn <- as.integer(dff[i,2, drop=FALSE])
if (yn==0){ # print("True")
ctrlx1[i]<-dff[i,1, drop=FALSE]
ctrlx1<-ctrlx1[!is.na(ctrlx1)] #ta global ass
ctrlx1 <<- ctrlx1
# print(ctrlx)
} else { # print("False")
expx1[i]<-dff[i,1, drop=FALSE]
expx1<-expx1[!is.na(expx1)]
expx1 <<- expx1 # ta global ass
# print(expx)
}
}
print(ctrlx1)
print(expx1)
}
ttesting(matr,dum)
splitcc <-function(dff){ # where dff is a data frame of x and y,
#x is a column/list and y is a dummy variable 0/1
ctrlx1 <<- vector("numeric")
expx1 <<- vector("numeric")
# splitt <<- matrix(,nrow = 2,ncol=52)
for (i in 1:nrow(matr)) {
yn <- as.integer(dff[i,2])
if (yn==0){ # print("True")
ctrlx1[i]<-dff[i,1]
ctrlx1<-ctrlx1[!is.na(ctrlx1)] #ta global ass
ctrlx1 <<- ctrlx1
# print(ctrlx)
} else { # print("False")
expx1[i]<-dff[i,1]
expx1<-expx1[!is.na(expx1)]
expx1 <<- expx1 # ta global ass
# print(expx)
}
}
print(ctrlx1)
print(expx1)
}
ttesting(matr,dum)
library(tidyverse)
data <- read.csv("https://raw.githubusercontent.com/gedeck/practical-statistics-for-data-scientists/master/data/house_sales.csv",
sep = "\t")
data <- data %>%
mutate(Ddate = as.Date(data$DocumentDate))
saveRDS(data, "\relative_path\file.rds")
data <- readRDS("\relative_path\file.rds")
# detach all libraries
detachAllPackages <- function() {
basic.packages <- c("package:stats", "package:graphics", "package:grDevices", "package:utils", "package:datasets", "package:methods", "package:base")
package.list <- search()[ifelse(unlist(gregexpr("package:", search()))==1, TRUE, FALSE)]
package.list <- setdiff(package.list, basic.packages)
if (length(package.list)>0)  for (package in package.list) detach(package,  character.only=TRUE)
}
detachAllPackages()
# load libraries
pkgTest <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[,  "Package"])]
if (length(new.pkg))
install.packages(new.pkg,  dependencies = TRUE)
sapply(pkg,  require,  character.only = TRUE)
}
# load necessary packages
lapply(c("ggplot2", "stargazer", "tidyverse", "stringr", "broom"),  pkgTest)
output_stargazer <- function(outputFile, appendVal=FALSE, ...) {
output <- capture.output(stargazer(...))
cat(paste(output, collapse = "\n"), "\n", file=outputFile, append=appendVal)
}
# set working directory to current parent folder
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# categories to intervals
dat <- readRDS("data/train.rds")
hist(dat$BldgGrade)
sort(unique(dat$BldgGrade))
with(dat, boxplot(AdjSalePrice ~ BldgGrade))
mod3 <- lm(dat$AdjSalePrice ~ as.ordered(dat$BldgGrade))
stargazer(mod3, type = "text")
stargazer(mod3, type = "html")
dat %>%
group_by(ZipCode) %>%
summarise(n = n()) %>%
arrange(desc(n)) %>%
ggplot(aes(as.factor(reorder(ZipCode, n)), n)) +
geom_col() +
coord_flip() +
xlab("Zip Code")
zip_group <- dat %>%
group_by(ZipCode) %>%
summarise(med_price = median(AdjSalePrice),
count = n()) %>%
arrange(med_price) %>%
mutate(cumul_count = cumsum(count),
ZipGroup = ntile(cumul_count, 5))
dat <- dat %>%
left_join(select(zip_group, ZipCode, ZipGroup), by = "ZipCode")
mod4 <- lm(AdjSalePrice ~ SqFtTotLiving + BldgGrade + ZipGroup, data = dat)
stargazer(mod4, type = "text")
modx <- lm(AdjSalePrice ~ SqFtTotLiving + BldgGrade, data = dat)
View(modx$residuals)
dat$residuals = modx$residuals
zip_group <- dat %>%
group_by(ZipCode) %>%
summarise(med_resid = median(residuals),
count = n()) %>%
arrange(med_resid) %>%
mutate(cumul_count = cumsum(count),
ZipGroup = ntile(cumul_count, 5))
dat <- dat %>%
left_join(select(zip_group, ZipCode, ZipGroup), by = "ZipCode")
mod4 <- lm(AdjSalePrice ~ SqFtTotLiving + BldgGrade + ZipGroup, data = dat)
stargazer(mod4, type = "text")
modx <- lm(AdjSalePrice ~ SqFtTotLiving + BldgGrade, data = dat)
View(modx$residuals)
dat$residuals = modx$residuals
zip_group <- dat %>%
group_by(ZipCode) %>%
summarise(med_resid = median(residuals),
count = n()) %>%
arrange(med_resid) %>%
mutate(cumul_count = cumsum(count),
ZipGroup = ntile(cumul_count, 5))
dat <- dat %>%
left_join(select(zip_group, ZipCode, ZipGroup), by = "ZipCode")
mod4 <- lm(AdjSalePrice ~ SqFtTotLiving + BldgGrade + ZipGroup, data = dat)
mod5 <- lm(AdjSalePrice ~ SqFtTotLiving + BldgGrade + as.factor(ZipGroup), data = dat)
stargazer(mod4, mod5,  out = "../Results/zipCodeModel.tex",  type = "latex")
stargazer("../Results/zipCodeModel.tex", mod4, type = "text")
dat %>% ggplot( aes(x=dat$SqFtTotLiving , y=AdjSalePrice,  group = BldgGrade)) +
geom_point(alpha = 0.5, aes(colour = as.factor(BldgGrade))) +
geom_line(data = dat_add, aes(y = .fitted, as.factor(BldgGrade))) # we change our data to the fitted values of the additive model
mod5 <- lm(AdjSalePrice ~ SqFtTotLiving + BldgGrade + as.factor(ZipGroup), data = dat)
stargazer("../Results/zipCodeModel.tex", mod4, type = "text")
getwd()
# detach all libraries
detachAllPackages <- function() {
basic.packages <- c("package:stats", "package:graphics", "package:grDevices", "package:utils", "package:datasets", "package:methods", "package:base")
package.list <- search()[ifelse(unlist(gregexpr("package:", search()))==1, TRUE, FALSE)]
package.list <- setdiff(package.list, basic.packages)
if (length(package.list)>0)  for (package in package.list) detach(package,  character.only=TRUE)
}
detachAllPackages()
# load libraries
pkgTest <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[,  "Package"])]
if (length(new.pkg))
install.packages(new.pkg,  dependencies = TRUE)
sapply(pkg,  require,  character.only = TRUE)
}
# load necessary packages
lapply(c("ggplot2", "stargazer", "tidyverse", "stringr", "broom"),  pkgTest)
# function to save output to a file that you can read in later to your docs
output_stargazer <- function(outputFile, appendVal=FALSE, ...) {
output <- capture.output(stargazer(...))
cat(paste(output, collapse = "\n"), "\n", file=outputFile, append=appendVal)
}
# set working directory to current parent folder
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# set working directory to current parent folder
setwd(~/housepricepred)
# set working directory to current parent folder
setwd("~/housepricepred")
getwd()
# categories to intervals
dat <- readRDS("data/train.rds")
modpol <- lm(AdjSalePrice ~ SqFtTotLiving + I(SqFtTotLiving^2) +
SqFtLot + Bathrooms + Bedrooms + BldgGrade + PropertyType +
as.factor(ZipGroup_r), data = dat)
modpol <- lm(AdjSalePrice ~ SqFtTotLiving + I(SqFtTotLiving^2) +
SqFtLot + Bathrooms + Bedrooms + BldgGrade + PropertyType +
as.factor(Zip_group), data = dat)
modpol <- lm(AdjSalePrice ~ SqFtTotLiving + I(SqFtTotLiving^2) +
SqFtLot + Bathrooms + Bedrooms + BldgGrade + PropertyType +
as.factor(zip_group), data = dat)
modpol <- lm(AdjSalePrice ~ SqFtTotLiving + I(SqFtTotLiving^2) +
SqFtLot + Bathrooms + Bedrooms + BldgGrade + PropertyType +
zip_group, data = dat)
modpol <- lm(AdjSalePrice ~ SqFtTotLiving + I(SqFtTotLiving^2) +
SqFtLot + Bathrooms + Bedrooms + BldgGrade + PropertyType +
zip_group, data = dat)
modpol <- lm(AdjSalePrice ~ SqFtTotLiving + I(SqFtTotLiving^2) +
SqFtLot + Bathrooms + Bedrooms + BldgGrade + PropertyType +
ZipGroup, data = dat)
zip_group <- dat %>%
group_by(ZipCode) %>%
summarise(med_resid = median(residuals),
count = n()) %>%
arrange(med_resid) %>%
mutate(cumul_count = cumsum(count),
ZipGroup = ntile(cumul_count, 5))
dat <- dat %>%
left_join(select(zip_group, ZipCode, ZipGroup), by = "ZipCode")
modpol <- lm(AdjSalePrice ~ SqFtTotLiving + I(SqFtTotLiving^2) +
SqFtLot + Bathrooms + Bedrooms + BldgGrade + PropertyType +
ZipGroup, data = dat)
mod5 <- lm(AdjSalePrice ~ SqFtTotLiving + BldgGrade + as.factor(ZipGroup), data = dat)
stargazer("../Results/zipCodeModel.tex", mod4, mod5, type = "text")
stargazer(mod4, mod5, modpol, type = "text")
# load necessary packages
lapply(c("ggplot2", "stargazer", "tidyverse", "stringr", "broom", "plot_ly"),  pkgTest)
terms_poly <- predict(mod5, type = "terms")
partial_resid_poly <- resid(modpol) + terms_poly
df_poly <- data.frame(SqFtTotLiving = dat[, "SqFtTotLiving"], # create a new data.frame of these vals
Terms = terms_poly[, "I(SqFtTotLiving^2)"],
PartialResid = partial_resid_poly[, "I(SqFtTotLiving^2)"])
df_poly <- data.frame(SqFtTotLiving = dat[, "SqFtTotLiving"], # create a new data.frame of these vals
Terms = terms_poly[, "I(SqFtTotLiving^2)"],
PartialResid = partial_resid_poly[, "I(SqFtTotLiving^2)"])
terms_poly <- predict(modpol, type = "terms")
df_poly <- data.frame(SqFtTotLiving = dat[, "SqFtTotLiving"], # create a new data.frame of these vals
Terms = terms_poly[, "I(SqFtTotLiving^2)"],
PartialResid = partial_resid_poly[, "I(SqFtTotLiving^2)"])
partial_resid_poly <- resid(modpol) + terms_poly
df_poly <- data.frame(SqFtTotLiving = dat[, "SqFtTotLiving"], # create a new data.frame of these vals
Terms = terms_poly[, "I(SqFtTotLiving^2)"],
PartialResid = partial_resid_poly[, "I(SqFtTotLiving^2)"])
ggplot(df_poly, aes(SqFtTotLiving, PartialResid)) +
geom_point(alpha = 0.2) +
geom_smooth() +
geom_line(aes(SqFtTotLiving, Terms), colour = "red")
par(mfrow = c(2, 2)) # we change the graphic device to show 4 plots at once
plot(mod4) # we supply our lm object to plot()
par(mfrow = c(2, 2)) # we change the graphic device to show 4 plots at once
plot(modpol) # we supply our lm object to plot()
modpol <- lm(AdjSalePrice ~ SqFtTotLiving + I(SqFtTotLiving^2) +
SqFtLot + Bathrooms + Bedrooms + BldgGrade + PropertyType +
ZipGroup, data = dat)
stargazer(mod4, mod5, modpol, type = "text")
# load necessary packages
lapply(c("ggplot2", "stargazer", "tidyverse", "stringr", "broom", "plot_ly", "car"),  pkgTest)
install.packages(new.pkg, dependencies = TRUE)
scatter.smooth(dat$SqFtTotLiving, resid(modpol), # plot a smooth line on the scatter plot
lpars = list(col = "blue", lwd = 3, lty = 3),
main = "Residual Plot (Sale Price ~ Size)",
xlab = "Total Living Area (sq.ft.)",
ylab = "Residuals")
abline(h = 0, col = "red")
par(mfrow = c(1,1))
avPlot(mod2, variable = "SqFtTotLiving")
avPlot(modpol, variable = "SqFtTotLiving")
